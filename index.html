<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Интерактивный кроссворд</title>
    <!-- Подключаем шрифт Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Обновляем размер сетки */
            --cell-size: 38px;
            --grid-size: 12; /* Новая сетка 12x12 */
            --border-color: #7d7d7d;
            --background-color: #f4f4f4;
            --active-color: #cceeff;
            --highlight-color: #fcf8e3;
            --correct-color: #b8f5b8;
            --incorrect-color: #fdbfbf;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            min-height: 100vh;
        }

        .crossword-container {
            width: 100%;
            max-width: 900px;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.05);
            padding: 25px;
            box-sizing: border-box;
        }
        
        h1 {
            text-align: center;
            color: #111;
            margin-top: 0;
            margin-bottom: 25px;
        }
        
        h1 a {
            color: inherit;
            text-decoration: none;
        }
        h1 a:hover {
            text-decoration: underline;
        }

        .main-content {
            display: flex;
            gap: 20px;
        }

        /* --- Сетка кроссворда --- */
        .crossword-grid {
            flex-grow: 1;
            display: grid;
            grid-template-columns: repeat(var(--grid-size), var(--cell-size));
            grid-template-rows: repeat(var(--grid-size), var(--cell-size));
            border: 2px solid #333;
            background-color: #333;
            gap: 1px;
            /* Небольшой фикс для мобильных */
            max-width: calc(var(--grid-size) * var(--cell-size) + 4px);
            max-height: calc(var(--grid-size) * var(--cell-size) + 4px);
        }

        .grid-cell {
            position: relative;
            background-color: #fff;
        }
        
        .grid-cell.blocked {
            background-color: #333;
        }

        .cell-input {
            width: 100%;
            height: 100%;
            padding: 0;
            margin: 0;
            border: none;
            box-sizing: border-box;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 500;
            text-transform: uppercase;
            background-color: transparent;
            color: #000;
            caret-color: #007bff;
            -moz-appearance: textfield;
            appearance: textfield;
        }
        
        .cell-input::-webkit-outer-spin-button,
        .cell-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .cell-input:focus {
            outline: none;
        }

        /* Динамические классы */
        .grid-cell.active .cell-input {
            background-color: var(--active-color);
        }
        
        .grid-cell.highlighted .cell-input {
            background-color: var(--highlight-color);
        }

        .grid-cell.active.highlighted .cell-input {
            background-color: var(--active-color);
        }

        .cell-input.correct {
            background-color: var(--correct-color) !important;
            color: #0a880a;
        }
        .cell-input.incorrect {
            background-color: var(--incorrect-color) !important;
            color: #d12020;
        }

        .cell-number {
            position: absolute;
            top: 2px;
            left: 3px;
            font-size: 0.6rem;
            font-weight: 700;
            color: #555;
            z-index: 1;
            pointer-events: none;
        }

        /* --- Список вопросов --- */
        .clues-container {
            width: 400px;
            flex-shrink: 0;
            height: calc(var(--grid-size) * var(--cell-size) + 2px); /* Синхронизируем высоту */
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .clues-container h2 {
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }

        .clues-list {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }
        
        .clues-list li {
            padding: 6px 8px;
            margin-bottom: 4px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s;
        }
        
        .clues-list li:hover {
            background-color: #f0f0f0;
        }
        
        .clues-list li.active-clue {
            background-color: var(--highlight-color);
            font-weight: 500;
        }
        
        /* Стили для ссылок в вопросах */
        .clues-list a {
            font-weight: 500;
            text-decoration: none;
            color: #0056b3;
        }
        .clues-list a:hover {
            text-decoration: underline;
        }

        /* --- Управление --- */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .controls button {
            padding: 10px 20px;
            font-size: 1rem;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #check-button {
            background-color: #4CAF50;
            color: white;
        }
        #check-button:hover {
            background-color: #45a049;
        }

        #clear-button {
            background-color: #f44336;
            color: white;
        }
        #clear-button:hover {
            background-color: #d32f2f;
        }
        
        #message-box {
            text-align: center;
            margin-top: 15px;
            font-weight: 500;
            font-size: 1.1rem;
            color: #4CAF50;
            min-height: 20px; /* Резервируем место */
        }
        
        /* Iframe для видео */
        .video-container {
            margin-top: 25px;
            text-align: center;
        }
        
        .video-container iframe {
            max-width: 100%;
            border-radius: 8px;
        }

        /* --- Адаптивность --- */
        @media (max-width: 800px) {
            .main-content {
                flex-direction: column;
                align-items: center; /* Центрируем сетку на мобильных */
            }
            .clues-container {
                width: 100%;
                max-width: calc(var(--grid-size) * var(--cell-size) + 4px);
                height: auto; /* Авто-высота для вопросов */
                max-height: 300px; /* Ограничиваем высоту с прокруткой */
            }
            .crossword-grid {
                 /* Уменьшаем ячейки, чтобы сетка влезла */
                --cell-size: 30px;
            }
        }
        @media (max-width: 450px) {
             .crossword-grid {
                /* Еще уменьшаем */
                --cell-size: 24px;
            }
            .clues-list li {
                font-size: 0.8rem;
            }
            h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>

    <div class="crossword-container">
        <h1>Кроссворд: <a href="https://www.youtube.com/watch?v=qKJh0S4w8sY" target="_blank">Связи структур</a></h1>
        
        <div class="main-content">
            <div class="crossword-grid" id="crossword-grid">
                <!-- Ячейки будут сгенерированы JavaScript -->
            </div>
            
            <div class="clues-container">
                <h2>По горизонтали</h2>
                <ol class="clues-list" id="clues-across"></ol>
                <h2>По вертикали</h2>
                <ol class="clues-list" id="clues-down"></ol>
            </div>
        </div>

        <div class="controls">
            <button id="check-button">Проверить</button>
            <button id="clear-button">Очистить</button>
        </div>

        <div id="message-box"></div>
        
        <div class="video-container">
            <h2>Видео на Bastyon</h2>
            <iframe width="560" style="aspect-ratio:1.777" src="https://bastyon.com/embedVideo.php?embed=true&s=6c7c385211dd9e02f01a3f5f3999e2daa8a7e4df215afd78cdfe7b09942d3ab3&host=peertube322.pocketnet.app&id=fbcf9741-17ce-4570-ae3a-529199718ddb" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const GRID_SIZE = 12; // Размер сетки 12x12
            const videoUrlBase = 'https://www.youtube.com/watch?v=qKJh0S4w8sY&t=';
            
            // 1. Данные кроссворда
            // Новая, логически корректная сетка, основанная на схеме,
            // но исправленная для совпадения букв.
            const crosswordData = [
                // Вертикальные слова
                { id: 1, direction: 'down', row: 0, col: 8, number: 1, answer: 'МАТРЁШКА', clue: `Принцип "вложенности" и повторения структур. (<a href="${videoUrlBase}20s" target="_blank">00:20</a>)` },
                { id: 2, direction: 'down', row: 1, col: 2, number: 2, answer: 'ИСТОК', clue: `Изначальная точка, из которой все разворачивается. (<a href="${videoUrlBase}424s" target="_blank">07:04</a>)` },
                { id: 4, direction: 'down', row: 4, col: 5, number: 4, answer: 'СОЗНАНИЕ', clue: `Проявление души и духа на физике. (<a href="${videoUrlBase}1353s" target="_blank">22:33</a>)` },
                
                // Горизонтальные слова
                { id: 3, direction: 'across', row: 2, col: 7, number: 3, answer: 'АТОМ', clue: `Упорядоченная совокупность частичек. (<a href="${videoUrlBase}2652s" target="_blank">44:12</a>)` }, // Пересекает МАТРЁШКА на 'Т'
                { id: 5, direction: 'across', row: 4, col: 0, number: 5, answer: 'СЛОВО', clue: `Звуковая программа или "ярлык" для донесения сути. (<a href="${videoUrlBase}1742s" target="_blank">29:02</a>)` }, // Пересекает ИСТОК на 'О'
                { id: 6, direction: 'across', row: 6, col: 5, number: 6, answer: 'ЗВУК', clue: `Основа движения в нашей реальности, вибрация. (<a href="${videoUrlBase}1683s" target="_blank">28:03</a>)` }, // Пересекает СОЗНАНИЕ на 'З' и МАТРЁШКА на 'К'
                { id: 7, direction: 'across', row: 8, col: 2, number: 7, answer: 'ОРГАН', clue: `Совокупность клеток, болеющая из-за вибраций. (<a href="${videoUrlBase}2694s" target="_blank">44:54</a>)` }  // Пересекает СОЗНАНИЕ на 'А'
            ];
            // Схема пересечений:
            // 1(Т) x 3(Т) @ (2,8)
            // 1(К) x 6(К) @ (6,8)
            // 2(О) x 5(О) @ (4,2)
            // 4(З) x 6(З) @ (6,5)
            // 4(А) x 7(А) @ (8,5)
            // Все 7 слов соединены.

            const gridElement = document.getElementById('crossword-grid');
            const cluesAcross = document.getElementById('clues-across');
            const cluesDown = document.getElementById('clues-down');
            const checkButton = document.getElementById('check-button');
            const clearButton = document.getElementById('clear-button');
            const messageBox = document.getElementById('message-box');
            
            // Массивы для хранения ссылок на элементы
            let gridCells = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            let gridInputs = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            // Структура для хранения данных о ячейках: { across: null, down: null }
            let gridCellData = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null).map(() => ({})));
            
            let activeCell = { row: null, col: null };
            let activeDirection = 'across';

            // 2. Генерация сетки
            function createGrid() {
                // 1. Создаем все ячейки
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell blocked'; // Изначально все ячейки заблокированы
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        gridElement.appendChild(cell);
                        gridCells[r][c] = cell;
                    }
                }

                // 2. "Прорезаем" слова и вставляем inputs
                crosswordData.forEach(word => {
                    const { id, direction, row, col, number, answer, clue } = word;
                    
                    for (let i = 0; i < answer.length; i++) {
                        const r = direction === 'across' ? row : row + i;
                        const c = direction === 'across' ? col + i : col;
                        
                        if (r >= GRID_SIZE || c >= GRID_SIZE) continue;

                        const cell = gridCells[r][c];
                        
                        // Если ячейка была заблокирована, "активируем" ее
                        if (cell.classList.contains('blocked')) {
                            cell.classList.remove('blocked');
                            
                            const input = document.createElement('input');
                            input.type = 'text';
                            input.maxLength = 1;
                            input.className = 'cell-input';
                            input.dataset.row = r;
                            input.dataset.col = c;
                            cell.appendChild(input);
                            gridInputs[r][c] = input; // Сохраняем ссылку на input
                        }
                        
                        // Сохраняем информацию о слове в ячейке
                        gridCellData[r][c][direction] = id;

                        // Добавляем номер вопроса
                        if (i === 0) {
                            const numberSpan = document.createElement('span');
                            numberSpan.className = 'cell-number';
                            numberSpan.textContent = number;
                            cell.appendChild(numberSpan);
                        }
                    }
                    
                    // 3. Добавляем вопросы в списки
                    const li = document.createElement('li');
                    li.innerHTML = `<b>${number}.</b> ${clue}`; // Используем innerHTML для рендеринга ссылки
                    li.dataset.id = id;
                    li.dataset.direction = direction;
                    li.dataset.row = row;
                    li.dataset.col = col;
                    
                    if (direction === 'across') {
                        cluesAcross.appendChild(li);
                    } else {
                        cluesDown.appendChild(li);
                    }
                });
            }

            // 3. Логика подсветки и активации
            function setActiveCell(row, col, direction) {
                // 1. Снимаем старую подсветку
                clearHighlights();

                // 2. Валидация
                if (row === null || col === null || !gridInputs[row][col]) {
                    activeCell = { row: null, col: null };
                    return;
                }
                
                // 3. Устанавливаем новое направление
                // Если ячейка принадлежит только одному направлению, принудительно его выбираем
                const cellData = gridCellData[row][col];
                if (cellData.across && !cellData.down) {
                    direction = 'across';
                } else if (!cellData.across && cellData.down) {
                    direction = 'down';
                }
                
                activeCell = { row, col };
                activeDirection = direction;

                // 4. Подсвечиваем активную ячейку
                gridCells[row][col].classList.add('active');

                // 5. Подсвечиваем слово
                const wordId = gridCellData[row][col][direction];
                if (!wordId) {
                     // Это может случиться, если направление было "across", а ячейка только "down"
                     // Пробуем сменить направление
                     if (direction === 'across' && cellData.down) {
                        activeDirection = 'down';
                     } else if (direction === 'down' && cellData.across) {
                         activeDirection = 'across';
                     }
                     // Повторный вызов с исправленным направлением
                     setActiveCell(row, col, activeDirection);
                     return;
                }
                
                const word = crosswordData.find(w => w.id === wordId);
                for (let i = 0; i < word.answer.length; i++) {
                    const r = word.direction === 'across' ? word.row : word.row + i;
                    const c = word.direction === 'across' ? word.col + i : word.col;
                    gridCells[r][c].classList.add('highlighted');
                }
                
                // 6. Подсвечиваем вопрос в списке
                const clueElement = document.querySelector(`.clues-list li[data-id="${wordId}"]`);
                if (clueElement) {
                    clueElement.classList.add('active-clue');
                    // Прокручиваем список к активному вопросу
                    clueElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
                
                // 7. Ставим фокус
                if (gridInputs[row][col]) {
                    gridInputs[row][col].focus();
                }
            }

            function clearHighlights() {
                document.querySelectorAll('.grid-cell.active').forEach(c => c.classList.remove('active'));
                document.querySelectorAll('.grid-cell.highlighted').forEach(c => c.classList.remove('highlighted'));
                document.querySelectorAll('.clues-list li.active-clue').forEach(c => c.classList.remove('active-clue'));
            }

            // 4. Обработчики событий
            
            // Клик по сетке
            gridElement.addEventListener('click', e => {
                if (e.target.classList.contains('cell-input')) {
                    const row = parseInt(e.target.dataset.row);
                    const col = parseInt(e.target.dataset.col);
                    
                    let newDirection = activeDirection;
                    // Если кликнули на ту же ячейку, меняем направление
                    if (row === activeCell.row && col === activeCell.col) {
                        newDirection = (activeDirection === 'across') ? 'down' : 'across';
                    }
                    
                    setActiveCell(row, col, newDirection);
                }
            });

            // Клик по вопросам
            cluesAcross.addEventListener('click', e => handleClueClick(e));
            cluesDown.addEventListener('click', e => handleClueClick(e));
            
            function handleClueClick(e) {
                 const li = e.target.closest('li'); // Находим <li>, даже если кликнули на <a>
                if (li) {
                    const row = parseInt(li.dataset.row);
                    const col = parseInt(li.dataset.col);
                    const direction = li.dataset.direction;
                    setActiveCell(row, col, direction);
                }
            }
            
            // Навигация с клавиатуры
            gridElement.addEventListener('keydown', e => {
                if (activeCell.row === null || !e.target.classList.contains('cell-input')) return;

                const { row, col } = activeCell;
                let r = row, c = col;

                switch (e.key) {
                    case 'ArrowRight':
                        c = findNextInput(r, c + 1, 'right');
                        break;
                    case 'ArrowLeft':
                        c = findNextInput(r, c - 1, 'left');
                        break;
                    case 'ArrowDown':
                        r = findNextInput(r + 1, c, 'down');
                        break;
                    case 'ArrowUp':
                        r = findNextInput(r - 1, c, 'up');
                        break;
                    case 'Backspace':
                        if (e.target.value === '') {
                             moveToPreviousCell();
                        }
                        return; // Не предотвращаем default
                    case 'Enter':
                    case 'Tab':
                        e.preventDefault();
                        moveToNextWord();
                        return;
                    default:
                        // Если вводим букву (простая проверка)
                        if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                             // Не двигаемся сразу, ждем 'input' event
                        }
                        return; // Не предотвращаем default
                }
                
                e.preventDefault();
                setActiveCell(r, c, activeDirection);
            });
            
            // Авто-переход при вводе
            gridElement.addEventListener('input', e => {
                if (e.target.value.length === 1) {
                    moveToNextCell();
                }
            });

            // --- Функции навигации ---
            function findNextInput(r, c, dir) {
                // Ищет следующий input в данном направлении
                while (r >= 0 && r < GRID_SIZE && c >= 0 && c < GRID_SIZE) {
                    if (gridInputs[r][c]) return (dir === 'up' || dir === 'down') ? r : c;
                    if (dir === 'right') c++;
                    if (dir === 'left') c--;
                    if (dir === 'down') r++;
                    if (dir === 'up') r--;
                }
                return (dir === 'up' || dir === 'down') ? activeCell.row : activeCell.col; // Не нашли, остаемся на месте
            }

            function moveToNextCell() {
                const { row, col } = activeCell;
                // Находим слово, которое сейчас активно
                const wordId = gridCellData[row][col][activeDirection];
                const word = crosswordData.find(w => w.id === wordId);
                if (!word) return;

                const wordLength = word.answer.length;
                const currentIndex = (activeDirection === 'across') ? (col - word.col) : (row - word.row);
                
                if (currentIndex < wordLength - 1) {
                    const nextRow = activeDirection === 'across' ? row : row + 1;
                    const nextCol = activeDirection === 'across' ? col + 1 : col;
                    if (gridInputs[nextRow][nextCol]) {
                        setActiveCell(nextRow, nextCol, activeDirection);
                    }
                }
            }

            function moveToPreviousCell() {
                 const { row, col } = activeCell;
                 // Находим слово, которое сейчас активно
                const wordId = gridCellData[row][col][activeDirection];
                const word = crosswordData.find(w => w.id === wordId);
                if (!word) return;

                const currentIndex = (activeDirection === 'across') ? (col - word.col) : (row - word.row);
                
                if (currentIndex > 0) {
                    const prevRow = activeDirection === 'across' ? row : row - 1;
                    const prevCol = activeDirection === 'across' ? col - 1 : col;
                    if (gridInputs[prevRow][prevCol]) {
                        setActiveCell(prevRow, prevCol, activeDirection);
                    }
                }
            }
            
             function moveToNextWord() {
                const currentWordId = gridCellData[activeCell.row][activeCell.col][activeDirection];
                const currentIndex = crosswordData.findIndex(w => w.id === currentWordId);
                
                let nextWord;
                if (currentIndex < crosswordData.length - 1) {
                    nextWord = crosswordData[currentIndex + 1];
                } else {
                    nextWord = crosswordData[0]; // Зацикливаем
                }
                
                setActiveCell(nextWord.row, nextWord.col, nextWord.direction);
            }

            // 5. Кнопки управления
            
            // Очистка
            clearButton.addEventListener('click', () => {
                gridInputs.flat().forEach(input => {
                    if (input) {
                        input.value = '';
                        input.classList.remove('correct', 'incorrect');
                    }
                });
                clearHighlights();
                messageBox.textContent = '';
                activeCell = { row: null, col: null };
            });

            // Проверка
            checkButton.addEventListener('click', () => {
                let allCorrect = true;
                let totalInputs = 0;
                let filledInputs = 0;
                
                gridInputs.flat().forEach(input => {
                    if (input) {
                        totalInputs++;
                        const r = parseInt(input.dataset.row);
                        const c = parseInt(input.dataset.col);
                        const cellData = gridCellData[r][c];
                        const userAnswer = input.value.toUpperCase();

                        if (userAnswer === '') {
                            allCorrect = false; 
                            input.classList.remove('correct', 'incorrect');
                            return; // Пропускаем пустые
                        }
                        
                        filledInputs++;
                        
                        // Ячейка считается правильной, ТОЛЬКО если она
                        // соответствует ВСЕМ словам, которые через нее проходят.
                        let isCellCorrect = true; 
                        let hasWord = false; 

                        // Проверяем ответ по горизонтали
                        if (cellData.across) {
                            hasWord = true;
                            const word = crosswordData.find(w => w.id === cellData.across);
                            const letterIndex = c - word.col;
                            if (word.answer[letterIndex] !== userAnswer) {
                                isCellCorrect = false; // Неверно для слова по горизонтали
                            }
                        }
                        
                        // Проверяем ответ по вертикали
                        if (cellData.down) {
                            hasWord = true;
                            const word = crosswordData.find(w => w.id === cellData.down);
                            const letterIndex = r - word.row;
                            if (word.answer[letterIndex] !== userAnswer) {
                                isCellCorrect = false; // Неверно для слова по вертикали
                            }
                        }
                        
                        if (hasWord) {
                            if (isCellCorrect) {
                                input.classList.add('correct');
                                input.classList.remove('incorrect');
                            } else {
                                input.classList.add('incorrect');
                                input.classList.remove('correct');
                                allCorrect = false; // Если хоть одна ячейка неверна
                            }
                        }
                    }
                });
                
                if (allCorrect && filledInputs === totalInputs && totalInputs > 0) {
                    messageBox.textContent = 'Кроссворд решен верно! Поздравляем!';
                    messageBox.style.color = '#4CAF50';
                    clearHighlights();
                } else if (!allCorrect) {
                     messageBox.textContent = 'Найдены ошибки. Попробуйте еще раз.';
                     messageBox.style.color = '#d32f2f';
                     setTimeout(() => { messageBox.textContent = ''; }, 3000);
                } else {
                    messageBox.textContent = 'Не все ячейки заполнены.';
                    messageBox.style.color = '#777';
                    setTimeout(() => { messageBox.textContent = ''; }, 3000);
                }
            });

            // 6. Инициализация
            createGrid();
            
            // Активируем первую ячейку первого слова
            if(crosswordData.length > 0) {
                const firstWord = crosswordData[0];
                setActiveCell(firstWord.row, firstWord.col, firstWord.direction);
            }
        });
    </script>
</body>
</html>
